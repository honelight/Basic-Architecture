/*
    Name 1: Dorian Johnson
    UTEID 1: dj5734
*/

/***************************************************************/
/*                                                             */
/*   LC-3b Simulator                                           */
/*                                                             */
/*   EE 360N                                                   */
/*   The University of Texas at Austin                         */
/*                                                             */
/***************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/***************************************************************/
/*                                                             */
/* Files:  ucode        Microprogram file                      */
/*         pagetable    page table in LC-3b machine language   */
/*         isaprogram   LC-3b machine language program file    */
/*                                                             */
/***************************************************************/

/***************************************************************/
/* These are the functions you'll have to write.               */
/***************************************************************/

void eval_micro_sequencer();
void cycle_memory();
void eval_bus_drivers();
void drive_bus();
void latch_datapath_values();

/***************************************************************/
/* A couple of useful definitions.                             */
/***************************************************************/
#define FALSE 0
#define TRUE  1

/***************************************************************/
/* Use this to avoid overflowing 16 bits on the bus.           */
/***************************************************************/
#define Low16bits(x) ((x) & 0xFFFF)

/***************************************************************/
/* Definition of the control store layout.                     */
/***************************************************************/
#define CONTROL_STORE_ROWS 64
#define INITIAL_STATE_NUMBER 18

/***************************************************************/
/* Definition of bit order in control store word.              */
/***************************************************************/
enum CS_BITS {
    IRD,
    COND1, COND0,
    J5, J4, J3, J2, J1, J0,
    LD_MAR,
    LD_MDR,
    LD_IR,
    LD_BEN,
    LD_REG,
    LD_CC,
    LD_PC,
    GATE_PC,
    GATE_MDR,
    GATE_ALU,
    GATE_MARMUX,
    GATE_SHF,
    PCMUX1, PCMUX0,
    DRMUX,
    SR1MUX,
    ADDR1MUX,
    ADDR2MUX1, ADDR2MUX0,
    MARMUX,
    ALUK1, ALUK0,
    MIO_EN,
    R_W,
    DATA_SIZE,
    LSHF1,
/* MODIFY: you have to add all your new control signals */
    BENMUX,
    LD_SP,
    INCSP,
    DECSP,
    GateSP,
    LD_PSR,
    IEMUX,
    LD_IE,
    GatePSR,
    GateVector,
    LD_VECTOR,
    VECTORMUX1, VECTORMUX0,
    LD_FAULT,
    CheckFault,
	GATE_PTBR,
	Gate_VA,
	LD_VA,
    CONTROL_STORE_BITS
} CS_BITS;

/***************************************************************/
/* Functions to get at the control bits.                       */
/***************************************************************/
int GetIRD(int *x)           { return(x[IRD]); }
int GetCOND(int *x)          { return((x[COND1] << 1) + x[COND0]); }
int GetJ(int *x)             { return((x[J5] << 5) + (x[J4] << 4) +
                                      (x[J3] << 3) + (x[J2] << 2) +
                                      (x[J1] << 1) + x[J0]); }
int GetLD_MAR(int *x)        { return(x[LD_MAR]); }
int GetLD_MDR(int *x)        { return(x[LD_MDR]); }
int GetLD_IR(int *x)         { return(x[LD_IR]); }
int GetLD_BEN(int *x)        { return(x[LD_BEN]); }
int GetLD_REG(int *x)        { return(x[LD_REG]); }
int GetLD_CC(int *x)         { return(x[LD_CC]); }
int GetLD_PC(int *x)         { return(x[LD_PC]); }
int GetGATE_PC(int *x)       { return(x[GATE_PC]); }
int GetGATE_MDR(int *x)      { return(x[GATE_MDR]); }
int GetGATE_ALU(int *x)      { return(x[GATE_ALU]); }
int GetGATE_MARMUX(int *x)   { return(x[GATE_MARMUX]); }
int GetGATE_SHF(int *x)      { return(x[GATE_SHF]); }
int GetPCMUX(int *x)         { return((x[PCMUX1] << 1) + x[PCMUX0]); }
int GetDRMUX(int *x)         { return(x[DRMUX]); }
int GetSR1MUX(int *x)        { return(x[SR1MUX]); }
int GetADDR1MUX(int *x)      { return(x[ADDR1MUX]); }
int GetADDR2MUX(int *x)      { return((x[ADDR2MUX1] << 1) + x[ADDR2MUX0]); }
int GetMARMUX(int *x)        { return(x[MARMUX]); }
int GetALUK(int *x)          { return((x[ALUK1] << 1) + x[ALUK0]); }
int GetMIO_EN(int *x)        { return(x[MIO_EN]); }
int GetR_W(int *x)           { return(x[R_W]); }
int GetDATA_SIZE(int *x)     { return(x[DATA_SIZE]); }
int GetLSHF1(int *x)         { return(x[LSHF1]); }
/* MODIFY: you can add more Get functions for your new control signals */
int GetVECTORMUX(int *x)      { return((x[VECTORMUX1] << 1) + x[VECTORMUX0]); }
/***************************************************************/
/* The control store rom.                                      */
/***************************************************************/
int CONTROL_STORE[CONTROL_STORE_ROWS][CONTROL_STORE_BITS];

/***************************************************************/
/* Main memory.                                                */
/***************************************************************/
/* MEMORY[A][0] stores the least significant byte of word at word address A
   MEMORY[A][1] stores the most significant byte of word at word address A
   There are two write enable signals, one for each byte. WE0 is used for
   the least significant byte of a word. WE1 is used for the most significant
   byte of a word. */

#define WORDS_IN_MEM    0x2000 /* 32 frames */
#define MEM_CYCLES      5
int MEMORY[WORDS_IN_MEM][2];

/***************************************************************/

/***************************************************************/

/***************************************************************/
/* LC-3b State info.                                           */
/***************************************************************/
#define LC_3b_REGS 8

int RUN_BIT;    /* run bit */
int BUS;        /* value of the bus */

typedef struct System_Latches_Struct{

int PC,         /* program counter */
    MDR,        /* memory data register */
    MAR,        /* memory address register */
    IR,         /* instruction register */
    N,          /* n condition bit */
    Z,          /* z condition bit */
    P,          /* p condition bit */
    BEN;        /* ben register */

int READY;      /* ready bit */
  /* The ready bit is also latched as you don't want the memory system to
     assert it at a bad point in the cycle*/

int REGS[LC_3b_REGS]; /* register file. */

int MICROINSTRUCTION[CONTROL_STORE_BITS]; /* the current microintruction */

int STATE_NUMBER; /* current state number - provided for debugging */ 

/* For lab 4 */
int INTV;       /* interrupt vector register */
int EXCV;       /* exception vector register */
int SSP;        /* initial value of system stack pointer */
/* MODIFY: you should add here any other registers you need to implement
   interrupts and exceptions */
int PRIVMODE; /* 0 for system, 1 for user (PSR[15]) */
int IE;       /* Interrupts Enabled */
int USP;      /* saved user stack pointer */
int VECTOR;   /* Int/exc vector */
int FAULT; /* Indicate whether this memory access caused a fault */
/* For lab 5 */
int PTBR;       /* this is initialized when we load the page table */
int VA;         /* temporary VA register */
/* MODIFY: you should add here any other registers you need to implement
   virtual memory */
int SEQ_SAVED_STATE_NUMBER;
} System_Latches;

/* Data Structure for Latch */

System_Latches CURRENT_LATCHES, NEXT_LATCHES;

/* For lab 5 */
#define PAGE_NUM_BITS 9
#define PTE_PFN_MASK 0x3E00
#define PTE_VALID_MASK 0x0004
#define PAGE_OFFSET_MASK 0x1FF

/***************************************************************/
/* A cycle counter.                                            */
/***************************************************************/
int CYCLE_COUNT;

/***************************************************************/
/*                                                             */
/* Procedure : help                                            */
/*                                                             */
/* Purpose   : Print out a list of commands.                   */
/*                                                             */
/***************************************************************/
void help() {                                                    
    printf("----------------LC-3bSIM Help-------------------------\n");
    printf("go               -  run program to completion       \n");
    printf("run n            -  execute program for n cycles    \n");
    printf("mdump low high   -  dump memory from low to high    \n");
    printf("rdump            -  dump the register & bus values  \n");
    printf("?                -  display this help menu          \n");
    printf("quit             -  exit the program                \n\n");
}

/***************************************************************/
/*                                                             */
/* Procedure : cycle                                           */
/*                                                             */
/* Purpose   : Execute a cycle                                 */
/*                                                             */
/***************************************************************/
void cycle() {                                                

    eval_micro_sequencer();   
    cycle_memory();
    eval_bus_drivers();
    drive_bus();
    latch_datapath_values();

    CURRENT_LATCHES = NEXT_LATCHES;

    CYCLE_COUNT++;
}

/***************************************************************/
/*                                                             */
/* Procedure : run n                                           */
/*                                                             */
/* Purpose   : Simulate the LC-3b for n cycles.                 */
/*                                                             */
/***************************************************************/
void run(int num_cycles) {                                      
    int i;

    if (RUN_BIT == FALSE) {
        printf("Can't simulate, Simulator is halted\n\n");
        return;
    }

    printf("Simulating for %d cycles...\n\n", num_cycles);
    for (i = 0; i < num_cycles; i++) {
        if (CURRENT_LATCHES.PC == 0x0000) {
            RUN_BIT = FALSE;
            printf("Simulator halted\n\n");
            break;
        }
        cycle();
    }
}

/***************************************************************/
/*                                                             */
/* Procedure : go                                              */
/*                                                             */
/* Purpose   : Simulate the LC-3b until HALTed.                 */
/*                                                             */
/***************************************************************/
void go() {                                                     
    if (RUN_BIT == FALSE) {
        printf("Can't simulate, Simulator is halted\n\n");
        return;
    }

    printf("Simulating...\n\n");
    while (CURRENT_LATCHES.PC != 0x0000)
        cycle();
    RUN_BIT = FALSE;
    printf("Simulator halted\n\n");
}

/***************************************************************/ 
/*                                                             */
/* Procedure : mdump                                           */
/*                                                             */
/* Purpose   : Dump a word-aligned region of memory to the     */
/*             output file.                                    */
/*                                                             */
/***************************************************************/
void mdump(FILE * dumpsim_file, int start, int stop) {          
    int address; /* this is a byte address */

    printf("\nMemory content [0x%0.4x..0x%0.4x] :\n", start, stop);
    printf("-------------------------------------\n");
    for (address = (start >> 1); address <= (stop >> 1); address++)
        printf("  0x%0.4x (%d) : 0x%0.2x%0.2x\n", address << 1, address << 1, MEMORY[address][1], MEMORY[address][0]);
    printf("\n");

    /* dump the memory contents into the dumpsim file */
    fprintf(dumpsim_file, "\nMemory content [0x%0.4x..0x%0.4x] :\n", start, stop);
    fprintf(dumpsim_file, "-------------------------------------\n");
    for (address = (start >> 1); address <= (stop >> 1); address++)
        fprintf(dumpsim_file, " 0x%0.4x (%d) : 0x%0.2x%0.2x\n", address << 1, address << 1, MEMORY[address][1], MEMORY[address][0]);
    fprintf(dumpsim_file, "\n");
}

/***************************************************************/
/*                                                             */
/* Procedure : rdump                                           */
/*                                                             */
/* Purpose   : Dump current register and bus values to the     */   
/*             output file.                                    */
/*                                                             */
/***************************************************************/
void rdump(FILE * dumpsim_file) {                               
    int k; 

    printf("\nCurrent register/bus values :\n");
    printf("-------------------------------------\n");
    printf("Cycle Count  : %d\n", CYCLE_COUNT);
    printf("PC           : 0x%0.4x\n", CURRENT_LATCHES.PC);
    printf("IR           : 0x%0.4x\n", CURRENT_LATCHES.IR);
    printf("STATE_NUMBER : 0x%0.4x\n\n", CURRENT_LATCHES.STATE_NUMBER);
    printf("BUS          : 0x%0.4x\n", BUS);
    printf("MDR          : 0x%0.4x\n", CURRENT_LATCHES.MDR);
    printf("MAR          : 0x%0.4x\n", CURRENT_LATCHES.MAR);
    printf("CCs: N = %d  Z = %d  P = %d\n", CURRENT_LATCHES.N, CURRENT_LATCHES.Z, CURRENT_LATCHES.P);
    printf("Registers:\n");
    for (k = 0; k < LC_3b_REGS; k++)
        printf("%d: 0x%0.4x\n", k, CURRENT_LATCHES.REGS[k]);
    printf("\n");

    /* dump the state information into the dumpsim file */
    fprintf(dumpsim_file, "\nCurrent register/bus values :\n");
    fprintf(dumpsim_file, "-------------------------------------\n");
    fprintf(dumpsim_file, "Cycle Count  : %d\n", CYCLE_COUNT);
    fprintf(dumpsim_file, "PC           : 0x%0.4x\n", CURRENT_LATCHES.PC);
    fprintf(dumpsim_file, "IR           : 0x%0.4x\n", CURRENT_LATCHES.IR);
    fprintf(dumpsim_file, "STATE_NUMBER : 0x%0.4x\n\n", CURRENT_LATCHES.STATE_NUMBER);
    fprintf(dumpsim_file, "BUS          : 0x%0.4x\n", BUS);
    fprintf(dumpsim_file, "MDR          : 0x%0.4x\n", CURRENT_LATCHES.MDR);
    fprintf(dumpsim_file, "MAR          : 0x%0.4x\n", CURRENT_LATCHES.MAR);
    fprintf(dumpsim_file, "CCs: N = %d  Z = %d  P = %d\n", CURRENT_LATCHES.N, CURRENT_LATCHES.Z, CURRENT_LATCHES.P);
    fprintf(dumpsim_file, "Registers:\n");
    for (k = 0; k < LC_3b_REGS; k++)
        fprintf(dumpsim_file, "%d: 0x%0.4x\n", k, CURRENT_LATCHES.REGS[k]);
    fprintf(dumpsim_file, "\n");
}

/***************************************************************/
/*                                                             */
/* Procedure : get_command                                     */
/*                                                             */
/* Purpose   : Read a command from standard input.             */  
/*                                                             */
/***************************************************************/
void get_command(FILE * dumpsim_file) {                         
    char buffer[20];
    int start, stop, cycles;

    printf("LC-3b-SIM> ");

    scanf("%s", buffer);
    printf("\n");

    switch(buffer[0]) {
    case 'G':
    case 'g':
        go();
        break;

    case 'M':
    case 'm':
        scanf("%i %i", &start, &stop);
        mdump(dumpsim_file, start, stop);
        break;

    case '?':
        help();
        break;
    case 'Q':
    case 'q':
        printf("Bye.\n");
        exit(0);

    case 'R':
    case 'r':
        if (buffer[1] == 'd' || buffer[1] == 'D')
            rdump(dumpsim_file);
        else {
            scanf("%d", &cycles);
            run(cycles);
        }
        break;

    default:
        printf("Invalid Command\n");
        break;
    }
}

/***************************************************************/
/*                                                             */
/* Procedure : init_control_store                              */
/*                                                             */
/* Purpose   : Load microprogram into control store ROM        */ 
/*                                                             */
/***************************************************************/
void init_control_store(char *ucode_filename) {                 
    FILE *ucode;
    int i, j, index;
    char line[200];

    printf("Loading Control Store from file: %s\n", ucode_filename);

    /* Open the micro-code file. */
    if ((ucode = fopen(ucode_filename, "r")) == NULL) {
        printf("Error: Can't open micro-code file %s\n", ucode_filename);
        exit(-1);
    }

    /* Read a line for each row in the control store. */
    for(i = 0; i < CONTROL_STORE_ROWS; i++) {
        if (fscanf(ucode, "%[^\n]\n", line) == EOF) {
            printf("Error: Too few lines (%d) in micro-code file: %s\n",
                   i, ucode_filename);
            exit(-1);
        }

        /* Put in bits one at a time. */
        index = 0;

        for (j = 0; j < CONTROL_STORE_BITS; j++) {
            /* Needs to find enough bits in line. */
            if (line[index] == '\0') {
                printf("Error: Too few control bits in micro-code file: %s\nLine: %d\n",
                       ucode_filename, i);
                exit(-1);
            }
            if (line[index] != '0' && line[index] != '1') {
                printf("Error: Unknown value in micro-code file: %s\nLine: %d, Bit: %d\n",
                       ucode_filename, i, j);
                exit(-1);
            }

            /* Set the bit in the Control Store. */
            CONTROL_STORE[i][j] = (line[index] == '0') ? 0:1;
            index++;
        }

        /* Warn about extra bits in line. */
        if (line[index] != '\0')
            printf("Warning: Extra bit(s) in control store file %s. Line: %d\n",
                   ucode_filename, i);
    }
    printf("\n");
}

/***************************************************************/
/*                                                             */
/* Procedure : init_memory                                     */
/*                                                             */
/* Purpose   : Zero out the memory array                       */
/*                                                             */
/***************************************************************/
void init_memory() {                                           
    int i;

    for (i=0; i < WORDS_IN_MEM; i++) {
        MEMORY[i][0] = 0;
        MEMORY[i][1] = 0;
    }
}

/**************************************************************/
/*                                                            */
/* Procedure : load_program                                   */
/*                                                            */
/* Purpose   : Load program and service routines into mem.    */
/*                                                            */
/**************************************************************/
void load_program(char *program_filename, int is_virtual_base) {                   
    FILE * prog;
    int ii, word, program_base, pte, virtual_pc;

    /* Open program file. */
    prog = fopen(program_filename, "r");
    if (prog == NULL) {
        printf("Error: Can't open program file %s\n", program_filename);
        exit(-1);
    }

    /* Read in the program. */
    if (fscanf(prog, "%x\n", &word) != EOF)
        program_base = word >> 1;
    else {
        printf("Error: Program file is empty\n");
        exit(-1);
    }

    if (is_virtual_base) {
        if (CURRENT_LATCHES.PTBR == 0) {
            printf("Error: Page table base not loaded %s\n", program_filename);
            exit(-1);
        }

        /* convert virtual_base to physical_base */
        virtual_pc = program_base << 1;
        pte = (MEMORY[(CURRENT_LATCHES.PTBR + (((program_base << 1) >> PAGE_NUM_BITS) << 1)) >> 1][1] << 8) | 
               MEMORY[(CURRENT_LATCHES.PTBR + (((program_base << 1) >> PAGE_NUM_BITS) << 1)) >> 1][0];

        printf("virtual base of program: %04x\npte: %04x\n", program_base << 1, pte);
        if ((pte & PTE_VALID_MASK) == PTE_VALID_MASK) {
          program_base = (pte & PTE_PFN_MASK) | ((program_base << 1) & PAGE_OFFSET_MASK);
          printf("physical base of program: %x\n\n", program_base);
          program_base = program_base >> 1; 
        } else {
          printf("attempting to load a program into an invalid (non-resident) page\n\n");
          exit(-1);
        }
    } else {
      /* is page table */
     CURRENT_LATCHES.PTBR = program_base << 1;
    }

    ii = 0;
    while (fscanf(prog, "%x\n", &word) != EOF) {
        /* Make sure it fits. */
        if (program_base + ii >= WORDS_IN_MEM) {
            printf("Error: Program file %s is too long to fit in memory. %x\n",
                   program_filename, ii);
            exit(-1);
        }

        /* Write the word to memory array. */
        MEMORY[program_base + ii][0] = word & 0x00FF;
        MEMORY[program_base + ii][1] = (word >> 8) & 0x00FF;;
        ii++;
    }

    if (CURRENT_LATCHES.PC == 0 && is_virtual_base) 
        CURRENT_LATCHES.PC = virtual_pc;

    printf("Read %d words from program into memory.\n\n", ii);
}

/***************************************************************/
/*                                                             */
/* Procedure : initialize                                      */
/*                                                             */
/* Purpose   : Load microprogram and machine language program  */ 
/*             and set up initial state of the machine         */
/*                                                             */
/***************************************************************/
void initialize(char *ucode_filename, char *pagetable_filename, char **program_filename, int num_prog_files) { 
    int i;
    init_control_store(ucode_filename);

    init_memory();
    load_program(pagetable_filename,0);
    for ( i = 0; i < num_prog_files; i++ ) {
        load_program(program_filename[i],1);
    }
    CURRENT_LATCHES.Z = 1;
    CURRENT_LATCHES.STATE_NUMBER = INITIAL_STATE_NUMBER;
    memcpy(CURRENT_LATCHES.MICROINSTRUCTION, CONTROL_STORE[INITIAL_STATE_NUMBER], sizeof(int)*CONTROL_STORE_BITS);
    CURRENT_LATCHES.SSP = 0x3000; /* Initial value of system stack pointer */

/* MODIFY: you can add more initialization code HERE */
	CURRENT_LATCHES.IE = 1;
	CURRENT_LATCHES.PRIVMODE = 1;
    NEXT_LATCHES = CURRENT_LATCHES;

    RUN_BIT = TRUE;
}

/***************************************************************/
/*                                                             */
/* Procedure : main                                            */
/*                                                             */
/***************************************************************/
int main(int argc, char *argv[]) {                              
    FILE * dumpsim_file;

    /* Error Checking */
    if (argc < 4) {
        printf("Error: usage: %s <micro_code_file> <page table file> <program_file_1> <program_file_2> ...\n",
               argv[0]);
        exit(1);
    }

    printf("LC-3b Simulator\n\n");

    initialize(argv[1], argv[2], &argv[3], argc - 3);

    if ( (dumpsim_file = fopen( "dumpsim", "w" )) == NULL ) {
        printf("Error: Can't open dumpsim file\n");
        exit(-1);
    }

    while (1)
        get_command(dumpsim_file);

}

/***************************************************************/
/* Do not modify the above code, except for the places indicated 
   with a "MODIFY:" comment.
   You are allowed to use the following global variables in your
   code. These are defined above.

   CONTROL_STORE
   MEMORY
   BUS

   CURRENT_LATCHES
   NEXT_LATCHES

   You may define your own local/global variables and functions.
   You may use the functions to get at the control bits defined
   above.

   Begin your code here                                        */
/***************************************************************/

/*#define WITHOUT_INTERRUPT
#undef WITH_DEBUG*/

/* Debugging / logging macros. */
#define TRACE() do { printf("%3d %s\n", __LINE__, __FUNCTION__); } while (0)

int _hush_debug;
#ifdef WITH_DEBUG
#define LLOG(fmt, ...) if (!_hush_debug) printf(fmt " (%s)\n", ## __VA_ARGS__, __FUNCTION__)
#define PANIC(fmt, ...) do { printf("%s: " fmt " (%s:%d)\n", __FUNCTION__, ## __VA_ARGS__, __FILE__, __LINE__); exit(20); } while(0)
#else
#define LLOG(fmt, ...) do {} while(0)
#define PANIC(fmt, ...) do {} while(0)
#endif


#define PROTFAULT  0x4
#define ALIGNFAULT 0x2
#define PAGEFAULT  0x1

/* For prettier, easier to debug code. */
#define MUX(choice, count, ...) ({ \
int v_[] = {__VA_ARGS__}, c_ = (choice); \
if (c_ >= (count)) PANIC("MUX out of bounds");\
v_[c_]; \
})


/* Some shortcuts. */
#define CL (CURRENT_LATCHES)
#define NL (NEXT_LATCHES)
#define CMI (CURRENT_LATCHES.MICROINSTRUCTION)
#define NMI (NEXT_LATCHES.MICROINSTRUCTION)


/**********************************************************
 Convenience routines
 These routines were written by Dorian Johnson and Marty Timmens
 for use in EE 460N Lab 2, Fall 2012 (unless otherwise noted).
 *********************************************************/

typedef int REG;
/* The SEXT function is from http://graphics.stanford.edu/~seander/bithacks.html#FixedSignExtend */
int SEXT(int val, unsigned bits)
{
     int const m = 1U << (bits - 1);
     val = val & ((1U << bits) - 1);  /* (Skip this if bits in x above position b are already zero.) */
     return (val ^ m) - m;
}

/* Set the NEXT_LATCHES ccs to match a value. */
void setCC(int val)
{
    NEXT_LATCHES.N = NEXT_LATCHES.Z = NEXT_LATCHES.P = 0;
    
    if (!(val & 0xffff))
        NEXT_LATCHES.Z = 1;
    else if (val & 0x8000)
        NEXT_LATCHES.N = 1;
    else
        NEXT_LATCHES.P = 1;
}

/* Extract an immediate of length `bits' in the rightmost bits */
int extractImmediate(int ir, int bits)
{
    /* I am too stupid to do this properly, so here's a jump table instead */
    switch (bits)
    {
        case 4:  return ir & 0xf;
        case 5:  return ir & 0x1f;
        case 6:  return ir & 0x3f;
        case 8:  return ir & 0xff;
        case 9:  return ir & 0x1ff;
        case 11: return ir & 0x7ff;
        default:
            PANIC("illegal bits");
    }
    
    return 0;
}

/* Loading memory */
unsigned char memGetByte(int addr)
{
    return MEMORY[addr >> 1][addr & 0x1] & 0xFF;
}
unsigned short memGetWord(int addr)
{
    if (addr % 2)
        PANIC("unaligned address for word read, 0x%04x", addr);
    
    return (memGetByte(addr+1) << 8) | memGetByte(addr);
}

/* Setting memory */
void memSetByte(int addr, unsigned char val)
{
    MEMORY[addr >> 1][addr & 0x1] = val;
}
void memSetWord(int addr, unsigned short val)
{
    if (addr % 2)
        PANIC("unaligned address for word write, 0x%04x", addr);
    
    memSetByte(addr, val & 0xFF);
    memSetByte(addr + 1, (val >> 8) & 0xFF);
}

/**********************************************************
 END Convenience routines
 *********************************************************/


/*** Banked R6 ***/

/* Get the value of a numbered register */
static int getRegVal(REG src)
{
    return SEXT(CURRENT_LATCHES.REGS[src] & 0xffff, 16);
}

/* Set the value of a numbered register */
static void setRegVal(REG dest, int val)
{
    NEXT_LATCHES.REGS[dest] = val & 0xffff;
    SEXT(val & 0xffff, 16);
}

/* Must be called immediately after NL.PRIVMODE is changed. */
static void bankRegisters()
{
    if (CL.PRIVMODE == NL.PRIVMODE)
        return;
    
    if (NL.PRIVMODE)
    {
        /* Changing from system (0) to user (1) */
        NEXT_LATCHES.SSP = getRegVal(6);
        setRegVal(6, CURRENT_LATCHES.USP);
    }
    else
    {
        /* Changing from user (1) to system (0) */
        NEXT_LATCHES.USP = getRegVal(6);
        setRegVal(6, CURRENT_LATCHES.SSP);
    }
}


/* Interrupts and exceptions */
static void generate_interrupts()
{
#ifndef WITHOUT_INTERRUPT
    if (CYCLE_COUNT == 300)
    {
        NL.INTV = 0x1;
        LLOG("\tGENERATING TIMER INTERRUPT");
    }
#endif
}

/*
 The shell will call these skeleton functions in the following order, and repeat the loop for each cycle.
 1. eval_micro_sequencer
 2. cycle_memory
 3. eval_bus_drivers
 4. drive_bus
 5. latch_datapath_values
 */

void eval_micro_sequencer()
{
    generate_interrupts();
    
    /*
     * Evaluate the address of the next state according to the
     * micro sequencer logic. Latch the next microinstruction.
     */
    int next_state_number = 0;
    
    if (CURRENT_LATCHES.STATE_NUMBER == 18 || CURRENT_LATCHES.STATE_NUMBER == 19)
    {
        LLOG("\n\n\n------------------------------------------------------", "");
        LLOG("===================     Fetch      ===================", "");
    }
    
   
    if (CMI[CheckFault] && (CL.FAULT & ALIGNFAULT))
    {
        next_state_number = 39;
        
        LLOG("\n\n\n******************************************************", "");
        LLOG("============== Alignment Fault Detected ==============", "");
        LLOG("******************************************************", "");
        LLOG("\n#%02d Next state is #%d due to ALIGNFAULT [$%d; IR=0x%04x]",
             CL.STATE_NUMBER, next_state_number, CYCLE_COUNT+1, CL.IR);
    }
	else if (CMI[CheckFault] && (CL.FAULT & PROTFAULT))
    {
        next_state_number = 26;
        
        LLOG("\n\n\n******************************************************", "");
        LLOG("============== Protection Fault Detected =============", "");
        LLOG("******************************************************", "");
        LLOG("\n#%02d Next state is #%d due to PROTFAULT [$%d; IR=0x%04x]",
             CL.STATE_NUMBER, next_state_number, CYCLE_COUNT+1, CL.IR);
    }
	else if (CMI[CheckFault] && (CL.FAULT & PAGEFAULT))
	{
		next_state_number = 55;
        
        LLOG("\n\n\n******************************************************", "");
        LLOG("================= Page Fault Detected ================", "");
        LLOG("******************************************************", "");
        LLOG("\n#%02d Next state is #%d due to PAGEFAULT [$%d; IR=0x%04x]",
             CL.STATE_NUMBER, next_state_number, CYCLE_COUNT+1, CL.IR);
	}
	else if (CMI[LD_VA])
	{
		LLOG("\n\n============ Doing Virtual Address translation ============", "");
		NL.SEQ_SAVED_STATE_NUMBER = GetJ(CMI);
		next_state_number = 40;
		LLOG("\n#%02d Next state is #%d due to LD_VA [$%d; IR=0x%04x]",
             CL.STATE_NUMBER, next_state_number, CYCLE_COUNT+1, CL.IR);
		LLOG("\tLatching %d into sequencer saved state", NL.SEQ_SAVED_STATE_NUMBER);
	}
	else if (GetJ(CMI) == 63)
	{
		LLOG("\n\n=========== Finished Virtual Address translation ===========", "");
		next_state_number = CL.SEQ_SAVED_STATE_NUMBER;
		LLOG("\n#%02d Next state is #%d [$%d; IR=0x%04x]",
             CL.STATE_NUMBER, next_state_number, CYCLE_COUNT+1, CL.IR);
	}
    else if (CMI[IRD])
    {
        next_state_number = (CL.IR & 0xF000) >> 12;
        
        char* instructions[] = {"BR", "ADD", "LDB", "STB", "JSR", "AND", "LDW",
            "STW", "RTI", "XOR", "U10", "U11",
            "JMP", "SHF", "LEA", "TRAP"};
        
        LLOG("\n\n\n======================================================", "");
        LLOG("===         Execute %4s @ 0x%04x [0x%04x]         ===",
			 instructions[ (CL.IR & 0xf000) >> 12], CL.PC-2, CL.MAR, "");
        LLOG("======================================================", "");
        
        LLOG("\n#%02d Next state is #%d due to instruction decode [$%d; IR=0x%04x]",
             CL.STATE_NUMBER, next_state_number, CYCLE_COUNT+1, CL.IR);
    }
    else
    {
        int is_first = !_hush_debug;
        next_state_number = GetJ(CMI);
        
        switch (GetCOND(CMI))
        {
            case 0:
                LLOG("\n#%02d Next state is #%d. [$%d; IR=0x%04x]",
                     CL.STATE_NUMBER, next_state_number, CYCLE_COUNT+1, CL.IR);
                break;
                
            case 1:
                if (CL.READY)
                    next_state_number |= 0x2;
                
                _hush_debug = 0;
                LLOG("%s#%02d Next state is #%d due to Memory ready M=%d [$%d; IR=0x%04x]",
                     is_first ? "\n" : "", CL.STATE_NUMBER, next_state_number, CL.READY, CYCLE_COUNT+1, CL.IR);
                
                _hush_debug = !CL.READY;
                break;
                
            case 2:
                if (CL.BEN)
                    next_state_number |= 0x4;
                
                if (CL.BEN && CL.STATE_NUMBER == 34)
                {
                    LLOG("\n\n\n******************************************************", "");
                    LLOG("============== Timer Interrupt Detected ==============", "");
                    LLOG("******************************************************", "");
                }
                
                LLOG("\n#%02d Next state is #%d due to BEN=%d [$%d; IR=0x%04x]",
                     CL.STATE_NUMBER, next_state_number,CL.BEN?1:0, CYCLE_COUNT+1, CL.IR);
                break;
                
            case 3:
                if (CL.IR & 0x800)
                    next_state_number |= 0x1;
                
                LLOG("\n#%02d Next state is #%d due to addressing mode I=%d. [$%d; IR=0x%04x]",
                     CL.STATE_NUMBER, next_state_number, (CL.IR & 0x800)?1:0, CYCLE_COUNT+1, CL.IR);
                break;
                
            default:
                PANIC("#%02d: invalid condition code??? [$%d; IR=0x%04x]",
                      CL.STATE_NUMBER, CYCLE_COUNT+1, CL.IR);
        }
    }
    
    NL.STATE_NUMBER = next_state_number;
    memcpy(NMI, CONTROL_STORE[next_state_number], CONTROL_STORE_BITS*sizeof(int));
    
    /* Just for debugging */
    switch (CL.STATE_NUMBER)
    {
        case 34:
            if (NL.STATE_NUMBER == 37)
                LLOG("\tInterrupt 0x%x detected.", CL.INTV);
            break;
        case 10:
        case 11:
            LLOG("\tIllegal opcode. Faulting.");
            break;
    }
}


int MEM_VAL;

void cycle_memory()
{
    static int memory_cycle_number = 0, blocked_address;
    
    if (!GetMIO_EN(CMI))
    {
        memory_cycle_number = blocked_address = -1;
        NL.READY = 0;
        return;
    }
    
    if ( (CMI[CheckFault] || CMI[LD_FAULT]) && (CL.FAULT))
    {
        LLOG("\tFault, so not cycling memory.");
        return;
    }
    
    
    LLOG("\tCycling memory (%s). MAR=0x%04x; Blocked=0x%04x; MDR=0x%04x; count=%d; mode=%s",
         GetR_W(CMI) ? "write" : "read", CL.MAR, blocked_address, CL.MDR,
         memory_cycle_number, CL.PRIVMODE ? "user" : "system");
    
    if (blocked_address != CL.MAR)
    {
        /* First cycle of a memory read */
        memory_cycle_number = 1;
        blocked_address = CL.MAR;
        NL.READY = 0;
        MEM_VAL = 0xDEAD;
        
        /* Protection & protection check -- these should be caught by sequencer,
         but check again here for debugging purposes. */
        /*if ((CL.PRIVMODE && CL.STATE_NUMBER != 28) && (blocked_address >= 0x0000) && (blocked_address <= 0x2fff))
            PANIC("LC3 SEGFAULT, user code attempted to load 0x%04x", blocked_address);*/
        
        if (GetDATA_SIZE(CMI) && (blocked_address & 0x1))
            PANIC("LC3 unaligned word access 0x%04x", blocked_address);
    }
    else if (memory_cycle_number == MEM_CYCLES-1)
    {
        if (GetR_W(CMI))
        {
            if (GetDATA_SIZE(CMI))
            {
                memSetWord(blocked_address, CL.MDR);
                LLOG("\tWrote a word to memory; MEM[0x%04x] = 0x%04x",
                     blocked_address, CL.MDR);
            }
            else
            {
                memSetByte(blocked_address, CL.MDR & 0xff);
                LLOG("\tWrote a byte to memory; MEM[0x%04x] = 0x%02x",
                     blocked_address, CL.MDR & 0xff);
            }
        }
        else
        {
            MEM_VAL = memGetWord(blocked_address & ~0x1);
            LLOG("\tRead memory address 0x%04x = 0x%04x",
                 blocked_address & ~0x1, MEM_VAL);
        }
        
        NL.READY = 1;
    }
    else if (memory_cycle_number < MEM_CYCLES-1)
    {
        MEM_VAL = 0xBEEF;
        NL.READY = 0;
    }
    
    memory_cycle_number++;
}

int ALU_VAL, MARMUX_VAL, SHF_VAL, MDR_VAL, ADDR_ADDER_VAL,
BEN_VAL, IE_VAL, SP_VAL, IE_VAL, VECTOR_VAL;

void eval_bus_drivers()
{
    /*
     * Datapath routine emulating operations before driving the bus.
     * Evaluate the input of tristate drivers
     */
    
    int SR1_OUT, SR2_OUT;
    
    /* Source registers */
    {
        REG SR1 = MUX(GetSR1MUX(CMI), 2,
                      ((CL.IR & 0xE00) >> 9), /* source IR[11:9] */
                      ((CL.IR & 0x1C0) >> 6)  /* source IR[8:6] */
                      );
        REG SR2 = (CL.IR & 0x7);
        
        SR1_OUT = getRegVal(SR1);
        SR2_OUT = getRegVal(SR2);
        
        LLOG("\t{SR1 = R%d = 0x%04x} {SR2 = R%d = 0x%04x}",
             SR1, SR1_OUT, SR2, SR2_OUT);
    }
    
    /* MDR */
    {
        if (GetDATA_SIZE(CMI))
        {
            /* word */
            MDR_VAL = SEXT(CL.MDR, 16);
        }
        else
        {
            /* byte */
            if (CL.MAR & 0x01)
                MDR_VAL = SEXT(CL.MDR >> 8, 8);
            else
                MDR_VAL = SEXT(CL.MDR & 0xff, 8);
        }
    }
    
    /* ALU */
    {
        int ALUA, ALUB;
        
        ALUB = MUX(CL.IR & 0x20 ? 1 : 0, 2,
                   SR2_OUT,
                   SEXT(extractImmediate(CL.IR, 5), 5)
                   ); /* SR2MUX */
        
        /*if (CL.IR & 0x20)
         LLOG("\tALUB = %d (imm5)", ALUB);
         else
         LLOG("\tALUB = R%d = 0x%04x", CL.IR & 0x7, ALUB);*/
        
        
        ALUA = SR1_OUT;
        
        ALU_VAL = MUX(GetALUK(CMI), 4,
                      ALUA + ALUB, /* ADD */
                      ALUA & ALUB, /* AND */
                      ALUA ^ ALUB, /* XOR */
                      ALUA         /* PASSA */
                      ) & 0xffff;
        
        char* op[] = {"+", "&", "^", "pt"};
        LLOG("\tALU_VAL = 0x%04x %s 0x%04x = 0x%04x",
             ALUA & 0xffff, op[GetALUK(CMI)], ALUB & 0xffff, ALU_VAL);
    }
    
    /* SHF. Contains code by Dorian Johnson and Marty Timmens from Lab 2, 460n Fall 2012. */
    {
        int amount4 = extractImmediate(CL.IR, 4);
        
        if (CL.IR & 0x10)
        {
            /* Right shift */
            if (CL.IR & 0x20)
            {
                /* arithmetic */
                /*LLOG("SHF >> %d (arithmetic)", amount4);*/
                SHF_VAL = (signed int)SR1_OUT >> (signed int)amount4;
            }
            else
            {
                /* logical */
                /*LLOG("SHF >> %d (logical)", amount4);*/
                SHF_VAL = ((unsigned int)SR1_OUT & 0xffff) >> amount4;
            }
        }
        else
        {
            /* Left shift */
            SHF_VAL = ( SR1_OUT & 0xffff) << amount4;
            /*LLOG("SHF << %d", amount4);*/
        }
        
        SHF_VAL &= 0xffff;
    }
    
    /* Address data path (MARMUX, ADDR_ADDER) */
    {
        int ADDR1MUX_VAL, ADDR2MUX_VAL;
        
        ADDR1MUX_VAL = MUX(GetADDR1MUX(CMI), 2,
                           CL.PC,  /* PC */
                           SR1_OUT /* BaseR */
                           );
        
        ADDR2MUX_VAL = MUX(GetADDR2MUX(CMI), 4,
                           0,                                      /* zero */
                           SEXT(extractImmediate(CL.IR, 6), 6),   /* offset6 ;select SEXT[IR[5:0]] */
                           SEXT(extractImmediate(CL.IR, 9), 9),   /* select SEXT[IR[8:0]] */
                           SEXT(extractImmediate(CL.IR, 11), 11)  /* PCoffset11 ;select SEXT[IR[10:0]] */
                           );
        
        if (GetLSHF1(CMI))
            ADDR2MUX_VAL <<= 1;
        
        ADDR_ADDER_VAL = ADDR1MUX_VAL + ADDR2MUX_VAL;
        
        LLOG("\tADDR_ADDER_VAL = (ADDR1MUX_VAL = 0x%04x) + (ADDR2MUX_VAL = 0x%04x) = 0x%04x",
             ADDR1MUX_VAL, ADDR2MUX_VAL, ADDR_ADDER_VAL);
        
        MARMUX_VAL = MUX(GetMARMUX(CMI), 2,
                         extractImmediate(CL.IR, 8) << 1,
                         ADDR_ADDER_VAL
                         );
    }
    
    /* BEN */
    {
        if (CMI[BENMUX])
        {
            BEN_VAL = CL.IE && CL.INTV;
            LLOG("\tBEN = %d = (IE=%d) & (INTV=%d)", BEN_VAL, CL.IE, CL.INTV);
            
        }
        else
        {
            BEN_VAL = ((CL.IR & 0x800) && CL.N) || ((CL.IR & 0x400) && CL.Z) || ((CL.IR & 0x200) && CL.P);
            LLOG("\tBEN = %d = {NZP=%d%d%d; IRNZP=%d%d%d}", BEN_VAL,
                 (CL.IR & 0x800) ? 1 : 0, (CL.IR & 0x400) ? 1 : 0, (CL.IR & 0x200) ? 1 : 0,
                 CL.N ? 1 : 0, CL.Z ? 1 : 0, CL.P ? 1 : 0);
        }
    }
    
    /* IE_VAL, interrupts enabled */
    {
        IE_VAL = MUX(CMI[IEMUX], 2, 0, 1);
    }
    
    /* SP_VAL, stack pointer */
    {
        SP_VAL = MUX(CMI[DECSP], 2,
                     getRegVal(6),
                     getRegVal(6) - 2,
                     ) & 0xffff;
    }
    
    /* VECTOR_VAL, exception or interrupt vector */
    {
        VECTOR_VAL = MUX(GetVECTORMUX(CMI), 4,
                         CL.INTV,
                         0x04,
                         0x03,
                         0x02);
    }
}


void drive_bus()
{
    /*
     * Datapath routine for driving the bus from one of the 5 possible
     * tristate drivers.
     */
    int bus_drives = 0;
    
    if (CMI[GATE_PC])
    {
        BUS = CL.PC;
        bus_drives++;
        LLOG("\tDriving PC 0x%04x onto bus.", BUS);
    }
    if (CMI[GATE_MDR] && !CMI[Gate_VA])
    {
        BUS = MDR_VAL & 0xffff;
        bus_drives++;
        LLOG("\tDriving MDR 0x%04x onto bus.", BUS);
    }
    if (CMI[GATE_ALU])
    {
        BUS = ALU_VAL;
        bus_drives++;
        LLOG("\tDriving ALU 0x%04x onto bus.", BUS);
    }
    if (CMI[GATE_MARMUX])
    {
        BUS = MARMUX_VAL;
        bus_drives++;
        LLOG("\tDriving MARMUX 0x%04x onto bus.", BUS);
    }
    if (CMI[GATE_SHF])
    {
        BUS = SHF_VAL;
        bus_drives++;
        LLOG("\tDriving SHF 0x%04x onto bus.", BUS);
    }
    if (CMI[GatePSR])
    {
        BUS = 0;
        BUS |= (CL.N << 2) | (CL.Z << 1) | (CL.P);
        BUS |= 0x8000;
        bus_drives++;
        LLOG("\tDriving PSR 0x%04x onto bus.", BUS);
    }
    if (CMI[GateSP])
    {
        BUS = SP_VAL;
        bus_drives++;
        LLOG("\tDriving SP 0x%04x onto bus.", BUS);
    }
    if (CMI[GateVector])
    {
        BUS = CL.VECTOR;
        bus_drives++;
        LLOG("\tDriving VECTOR 0x%04x onto bus.", BUS);
    }
	
	if (CMI[Gate_VA])
	{
		if (CMI[GATE_MDR])
		{
			BUS = (CL.MDR & 0x3E00) | (CL.VA & 0x1ff);
			bus_drives++;
			LLOG("\tDriving MDR[13:9]'VA[8:0] = 0x%04x onto bus"
				 " (MDR=0x%04x; VA=0x%04x).", BUS, CL.MDR, CL.VA);
		}
		else if (CMI[GATE_PTBR])
		{
			BUS = (CL.PTBR & 0xFF00) | ((CL.VA & 0xFE00) >> 8);
			bus_drives++;
			LLOG("\tDriving PTBR[15:8]'LSHF(VA[15:9]) = 0x%04x onto bus"
				 " (PTBR=0x%04x; VA=0x%04x).", BUS, CL.PTBR, CL.VA);
		}
		
	}
    
    if (bus_drives == 0)
        BUS = 0x0; /* If nothing is driving bus, put 0 */
    else if (bus_drives > 1)
        PANIC("Magic smoke is pouring out of the processor. (state #%d)",
              CL.STATE_NUMBER);
}

void latch_datapath_values()
{
    /*
     * Datapath routine for computing all functions that need to latch
     * values in the data path at the end of this cycle.  Some values
     * require sourcing the bus; therefore, this routine has to come
     * after drive_bus.
     */
    
    int MDRMUX_VAL, INMUX_VAL;
    
    
    MDRMUX_VAL = MUX(GetMIO_EN(CMI), 2,
                     BUS,
                     MEM_VAL
                     );
    
    if (CMI[LD_MAR])
    {
        NL.MAR = BUS & 0xffff;
        LLOG("\tLatching 0x%04x into MAR.", NL.MAR);
    }
    if (CMI[LD_PC])
    {
        NL.PC = MUX(GetPCMUX(CMI), 4,
                    CL.PC + 2,
                    BUS,
                    ADDR_ADDER_VAL,
                    CL.PC - 2
                    )  & 0xffff;
        char* reasons[] = {"PC+2", "BUS", "ADDR_ADDER", "PC-2"};
        LLOG("\tLatching 0x%04x into PC (%s).", NL.PC, reasons[GetPCMUX(CMI)]);
    }
    if (CMI[LD_FAULT])
    {
        int addr = CL.VA;
		int pte = MEM_VAL;
		NL.FAULT = 0;
		
		if (CL.PRIVMODE && !(pte & 0x8))
			NL.FAULT |= PROTFAULT;
		if (!(pte & 0x4))
			NL.FAULT |= PAGEFAULT;
		if ((addr & 0x1) && (CL.SEQ_SAVED_STATE_NUMBER != 29) && (CL.SEQ_SAVED_STATE_NUMBER != 24))
			NL.FAULT |= ALIGNFAULT;
        
		if (NL.FAULT)
			LLOG("\tLatching PROTFAULT=%d; ALIGNFAULT=%d PAGEFAULT=%d "
				 "(VA=0x%04x; PTE=0x%04x)", NL.FAULT&PROTFAULT,
				 NL.FAULT&ALIGNFAULT, NL.FAULT&PAGEFAULT, addr&0xffff, pte&0xffff);
    }
    else if (!CMI[CheckFault])
    {
        NL.FAULT = 0;
        /*LLOG("\t\tClearing PRIVFAULT=ALIGNFAULT=0");*/
    }

    if (CMI[LD_MDR])
    {
        if ((CMI[CheckFault] && CL.FAULT) ||
            (CMI[LD_FAULT]   && CL.FAULT) ||
            (CMI[LD_FAULT]   && CMI[CheckFault]) )
        {
            NL.MDR = (CL.PC - 2) & 0xffff;
            LLOG("\tLatching PC-2=0x%04x into MDR.", NL.MDR);
        }
		else if (CMI[GATE_MDR])
		{
			int write = (CL.SEQ_SAVED_STATE_NUMBER == 23) ||
			            (CL.SEQ_SAVED_STATE_NUMBER == 24);
			NL.MDR = MDRMUX_VAL | (write ? 0x2 : 0) | 0x1;
			LLOG("\tLatching BUS|R%s = 0x%04x into MDR.",
				 write ? "|W" : "", NL.MDR);
		}
        else
        {
            NL.MDR = MDRMUX_VAL & 0xffff;
            LLOG("\tLatching 0x%04x into MDR.", NL.MDR);
        }
    }
    if (CMI[LD_IR])
    {
        NL.IR = BUS & 0xffff;
        LLOG("\tLatching 0x%04x into IR.", NL.IR);
    }
    if (CMI[LD_REG])
    {
        REG DRMUX = MUX(GetDRMUX(CMI), 2,
                        ((CL.IR & 0xE00) >> 9), /* destination IR[11:9] */
                        0x7                     /* destination R7 */
                        );
        
        LLOG("\tLatching 0x%04x into R%d", BUS&0xffff, DRMUX);
        setRegVal(DRMUX, BUS);
    }
    if (CMI[LD_CC])
    {
        LLOG("\tLatching CC from bus: %d", SEXT(BUS, 16));
        setCC(BUS);
    }    
    if (CMI[LD_BEN])
    {
        NL.BEN = BEN_VAL;
        LLOG("\tLatching %d into BEN.", NL.BEN);
    }
    
    if (CMI[LD_SP])
    {
        setRegVal(6, CMI[INCSP] ? SP_VAL + 2 : SP_VAL);
        LLOG("\tLatching 0x%04x into SP.", CMI[INCSP] ? SP_VAL + 2 : SP_VAL);
    }
    
    if (CMI[LD_PSR])
    {
        NL.N = BUS & 0x4;
        NL.Z = BUS & 0x2;
        NL.P = BUS & 0x1;
        /*NL.PRIVMODE = BUS & 0x8000;*/
        bankRegisters();
        LLOG("\tLatching 0x%04x into PSR.", BUS & 0xffff);
    }
    
    if (CMI[LD_IE])
    {
        NL.IE = IE_VAL;
        LLOG("\tLatching %d into IE.", IE_VAL);
        
        NL.PRIVMODE = IE_VAL;
        bankRegisters();
        LLOG("\tChanging privilege level to %s.", NL.PRIVMODE ? "user" : "system");
    }
    
    if (CMI[LD_VECTOR])
    {
        NL.VECTOR = (0x200 + (VECTOR_VAL << 1)) & 0xffff;
        LLOG("\tLatching 0x%04x into VECTOR.", NL.VECTOR);
        
        switch (GetVECTORMUX(CMI)) {
            case 0:
                NL.INTV = 0;
                LLOG("\tClearing INTV (transfered to VECTOR).");
                break;
                
            default:
                LLOG("\tSetting EXCV=%d.", VECTOR_VAL);
                NL.EXCV = VECTOR_VAL;
                break;
        }
    }
	
	if (CMI[LD_VA])
	{
		NL.VA = BUS & 0xffff;
		LLOG("\tLatching 0x%04x into VA.", NL.VA);
	}
}